using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;
namespace kernel_utility
{
    public class kutil
    {
        /*/
         * THESE ARE REALLY IMPORTANT TO HAVE R/W ARBITARY ON KERNELBASE.dll
        /*/

        [System.Runtime.InteropServices.DllImport("kernel32.dll")]
        public static extern void ReadProcessMemory(IntPtr task,long vm_address,byte[] data,int length,int mm);

        [System.Runtime.InteropServices.DllImport("kernel32.dll")]
        public static extern void WriteProcessMemory(IntPtr task, long vm_address, byte[] data, int length, int mm);
        
        [System.Runtime.InteropServices.DllImport("kernel32.dll")]
        public static extern IntPtr OpenProcess(int vm_prot, bool ff, int pid_t);

        [System.Runtime.InteropServices.DllImport("kernel32.dll", SetLastError = true)]
        static extern bool VirtualProtectEx(IntPtr hProcess, long lpAddress,
        int dwSize, uint flNewProtect, out uint lpflOldProtect);
        static long client = 0;
        public const int
        PAGE_READWRITE = 0x40,
        PROCESS_VM_OPERATION = 0x0008,
        PROCESS_VM_READ = 0x0010,
        PROCESS_VM_WRITE = 0x0020;
        public int pid__t = 0x0;
        int pid_t(int pid)
        {
            return pid;
        }
        public string LOG(string fmt,long arg)
        {
            Console.WriteLine("$ " +fmt, arg);
            return "$ " + fmt + arg.ToString();
        }

      


        public IntPtr task_for_pid(int type,bool acc,int pid_t)
        {
            //LOG("TARGET_PROC -> {0}", (int)OpenProcess((int)type, acc, pid_t));
            return OpenProcess((int)type, acc, pid_t);
        }
        
    

        public void k_write32(IntPtr tfp,long vm_addr_t,int data)
        {
            uint kek;
            VirtualProtectEx(tfp, vm_addr_t,20, PAGE_READWRITE, out kek);
            WriteProcessMemory(tfp, vm_addr_t, BitConverter.GetBytes(data), BitConverter.GetBytes(data).Length, 0);
        }
        public void k_stabilityrwe(IntPtr tfp, long vm_addr_t, int data)
        {
            uint kek;
            VirtualProtectEx(tfp, vm_addr_t, 100000, 0x20, out kek);
            //LOG(" * REALLOCATED -> 0x{0}", vm_addr_t);

        }
        public void k_noaccess(IntPtr tfp, long vm_addr_t, int data)
        {
            uint kek;
            VirtualProtectEx(tfp, vm_addr_t, 100000, 2, out kek);
         
        }
        public Int64 k_read64(IntPtr tfp,long addr,int size)
        {
            byte[] kern_ret = new byte[size];
            ReadProcessMemory(tfp, addr, kern_ret, size, 0);
            return BitConverter.ToInt64(kern_ret,0); //HANDLY STUFF HERE
        }

        public string k_readStr(IntPtr tfp,long vm_addr_t)
        {
            byte[] data = new byte[20];
            string readable_by_human = ASCIIEncoding.ASCII.GetString(data);
          
            ReadProcessMemory(tfp, vm_addr_t, data, 20, 0);
            return readable_by_human;
        }

    }
}
